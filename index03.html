<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mini-Solid</title>
  </head>
  <body>
    <div id="root"></div>
    <script>
      const UNOWNED = {
        owned: null,
        cleanups: null,
        context: null,
        owner: null
      };
      let runEffects = runQueue;
      let Owner = null
      let Listener = null
      function createSignal(value) {
        const s = {
          value,
          observers: null,
        };

        const setter = (value) => {
          return writeSignal(s, value)
        };

        return [readSignal.bind(s), setter]
      }
      
      function readSignal() {
        if (Listener) {
          if (!this.observers) {
            this.observers = [Listener]
          } else {
            this.observers.push(Listener)
          }
        }
        return this.value
      }

      function writeSignal(node, value,) {
        node.value = value
        if (node.observers && node.observers.length) {
          for (let i = 0; i < node.observers.length; i += 1) {
            const o = node.observers[i]
            o.fn()
          }
        }
        return value
      }

      function createEffect(fn) {
        const c = createComputation(fn)
        updateComputation(c)
      }

      function createComputation(fn) {
        const c = {
            fn,
        };
        return c
      }

      function updateComputation(node) {
        if (!node.fn) return
        runComputation(node)
      }

      function runComputation(node) {
        let nextValue;
        const owner = Owner,
            listener = Listener;
        Listener = Owner = node;
        try {
            nextValue = node.fn();
        } catch (err) {
            console.error(err)
        } finally {
            Listener = listener;
            Owner = owner;
        }
      }

      export function render(code, element, init, options = {}) {
        let disposer;
        createRoot(dispose => {
            disposer = dispose;
            element === document
            ? code()
            : insert(element, code(), element.firstChild ? null : undefined, init);
        }, options.owner);
        return () => {
            disposer();
            element.textContent = "";
        };
      }

      function template(html, isCE) {
        let node;
        const create = () => {
            const t = document.createElement("template")
            t.innerHTML = html
            return t.content.firstChild
        }
        const fn = isCE ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true)
        fn.cloneNode = fn
        return fn
      }

      function createRoot(fn, detachedOwner) {
        const listener = Listener,
        owner = Owner,
        unowned = fn.length === 0,
        current = detachedOwner === void 0 ? owner : detachedOwner,
        root = unowned ? {
            owned: null,
            cleanups: null,
            context: null,
            owner: null
        } : {
            owned: null,
            cleanups: null,
            context: current ? current.context : null,
            owner: current
        }, 
        updateFn = unowned ? () => fn(() => {
            throw new Error("Dispose method must be an explicit argument to createRoot function");
        }) : () => fn(() => untrack(() => cleanNode(root)))

        Owner = root;
        Listener = null;
        try {
            return runUpdates(updateFn, true);
        } finally {
            Listener = listener;
            Owner = owner;
        }
      }

      function runUpdates(fn, init) {
        if (Updates)
            return fn();
        let wait = false;
        if (!init)
            Updates = [];
        if (Effects)
            wait = true;
        else
            Effects = [];
        ExecCount++;
        try {
            const res = fn();
            completeUpdates(wait);
            return res;
        } catch (err) {
            if (!wait)
            Effects = null;
            Updates = null;
            // handleError(err);
        }
      }

      function completeUpdates(wait) {
        if (Updates) {
            runQueue(Updates);
            Updates = null;
        }
        if (wait) return;
        const e = Effects;
        Effects = null;
        if (e.length) {
            runUpdates(() => runEffects(e), false)
        }
      }

      function createComponent(Comp, props) {
        return untrack(() => Comp(props));
      }

      function untrack(fn) {
        const listener = Listener;
        Listener = null;
        try {
            return fn();
        } finally {
            Listener = listener;
        }
      }

      function runQueue(queue) {
        for (let i = 0; i < queue.length; i++) runTop(queue[i]);
      }

      function runTop(node) {

      }

      const [count, setCount] = createSignal(1)
      createEffect(() => {
        console.log('count 值的变化：', count())
      })
      setInterval(() => {
        setCount(count() + 1)
      }, 3000)
    </script>
  </body>
</html>
